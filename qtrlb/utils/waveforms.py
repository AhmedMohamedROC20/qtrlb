import scipy.signalimport matplotlib.pyplot as pltimport numpy as npimport copydef get_waveform(length: int, shape: str):    """    Generate the waveform for Qblox to play.    It has to return list, not ndarray.    Each element has to be float (not integer) between 0.0 and 1.0.    """        # Check the length is integer    if int(length) != length:        print(f'The waveform length {length} is not interger and will be rounded to {int(length)}.')        length = int(length)        if shape == 'square':        waveform = square(length)    elif shape == 'gaussian':        waveform = gaussian(length)    elif shape == 'cos_square':        waveform = cos_square(length)    else:        raise ValueError(f'The waveform shape "{shape}" has not been defined.')         return waveform    def plot_waveform(length: int, shape: str):    """    Plot waveform amplitude as time.    """    time = [i for i in range(length)]    waveform = get_waveform(length, shape)    fig, ax = plt.subplots(1,1)    ax.plot(time, waveform)    ax.set(xlabel='Time[ns]', ylabel='Amplitude[a.u.]', title=f'{length}ns {shape} waveform.')    ax.hlines(y=0, xmin=time[0], xmax=time[-1], color='black', linestyle='dashed', alpha=0.4)    ax.hlines(y=1, xmin=time[0], xmax=time[-1], color='black', linestyle='dashed', alpha=0.4)    ax.set_ylim(-0.05, 1.05)    fig.show()            def square(length: int):    return [1.0 for i in range(length)]        def gaussian(length: int, std: float = 0.15):    return scipy.signal.gaussian(length, std=std*length).tolist()    def cos_square(length: int, ramp_fraction: float = 0.25):    ramp_length = int(length * ramp_fraction)    ramp_up = [np.sin(np.pi/2*i/ramp_length)**2 for i in range(ramp_length)]    ramp_down = copy.deepcopy(ramp_up)    ramp_down.reverse()    return ramp_up + [1.0 for i in range(length-ramp_length*2)] + ramp_down        