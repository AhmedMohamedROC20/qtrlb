# =============================================================================# All the function in this script are supposed to be purely mathematical without# considering the parameter or dictionary structure of measurement, so that it # could also be called for other purpose.# # Support both nested list and ndarray. Please make sure the first index is 0# for I_data and 1 for Q_data.# # I'm also working on support both Scan and Scan2D where the data for 1D has # shape (2, n_reps, x_points) and Scan2D has shape (2, n_reps, x_points, y_points).# # TODO: Maybe 2D Scan can also keep the original 1D shape. # # And we reshape it after processing, before plot, or before fit.# =============================================================================import numpy as npfrom sklearn.mixture import GaussianMixturePI = np.pidef rotate_IQ(input_data: list | np.ndarray, angle: float):    """    Rotate all IQ data with angle in radian.    """    input_data = np.array(input_data)    if angle < -2*PI or angle > 2*PI:        print(f'Processing: Rotate angle {angle} may not in radian!')            rot_matrix = [[np.cos(angle), -np.sin(angle)],                   [np.sin(angle), np.cos(angle)]]        result = np.einsum('ij,j...->i...', rot_matrix, input_data)    return result    def gmm_predict(input_data, means, covariances, covariance_type='spherical'):    """    Predict the state of input data based on given means and covariances of GMM.    By default, means should have shape (n_components, 2) for 2D gaussian.    Covariances should have shape (n_components,) for symmetrical distribution,    where n_components is the number of Gaussian blob in IQ plane.        Reference:    https://scikit-learn.org/stable/modules/generated/sklearn.mixture.GaussianMixture.html    """    input_data = np.array(input_data)    means = np.array(means)    covariances = np.array(covariances)    n_components = len(means)        gmm = GaussianMixture(n_components, covariance_type=covariance_type)    gmm.means_ = means    gmm.covariances_ = covariances    gmm.precisions_cholesky_ = 1/covariances    gmm.weights_  = np.ones(n_components)    result = gmm.predict(input_data.reshape(2,-1).T).reshape(input_data.shape[1:])    # Magic reshape stealing from Ray.    return resultdef gmm_fit(input_data, n_components: int, covariance_type='spherical'):    """    Fit the input data with GMM. User must specify number of Gaussian blobs.    Return the means and covariances. Means have shape (n_components, 2).    Covariances have shape (n_components,) for symmetrical 2D distribution.    """    input_data = np.array(input_data)    gmm = GaussianMixture(n_components, covariance_type=covariance_type)    gmm.fit(input_data.reshape(2,-1).T)    return gmm.means_, gmm.covariances_